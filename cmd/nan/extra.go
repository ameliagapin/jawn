package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/markbates/pkger"
)

const (
	initialTypeName  = "initialTemplateType"
	generateTypeName = "nullTemplateType"
	valueFieldName   = "Value initialTemplateType"
	packageName      = "package nan"
)

func generateExtra() {
	pkgName := flag.String("pkg", "", "specify generated package name. By default will use working directory name")

	flag.Parse()

	if *pkgName == "" {
		wd, err := os.Getwd()
		if err != nil {
			panic(err)
		}

		_, *pkgName = filepath.Split(wd)
	}

	files := flag.Args()

	for _, file := range files {
		fset := token.NewFileSet()

		parsed, err := parser.ParseFile(fset, file, nil, 0)
		if err != nil {
			panic(err)
		}

		filenameNan := pkger.Include("/nan_template.go")

		fileNan, err := pkger.Open(filenameNan)
		if err != nil {
			panic(err)
		}

		defer fileNan.Close()

		dataNan, err := ioutil.ReadAll(fileNan)
		if err != nil {
			panic(err)
		}

		var out string

		var name string

		ast.Inspect(parsed, func(node ast.Node) bool {
			switch val := node.(type) {
			case *ast.File:
				// fmt.Println("file", val.Name.String())
				return true
			case *ast.GenDecl:
				// fmt.Println("decl", val.Tok.String())
				return true
			case *ast.TypeSpec:
				// fmt.Println("spec", val.Name.String())
				return true
			case *ast.Ident:
				// fmt.Println("ident", val.Name)
				name = val.Name
				return true
			case *ast.StructType:
				if name == "" {
					return false
				}

				var buf bytes.Buffer

				printer.Fprint(&buf, fset, val)
				// println(buf.String())

				var nullPrefix string

				// Name starts with uppercased letter - exported
				if strings.ToUpper(string([]rune(name)[0])) == string([]rune(name)[0]) {
					nullPrefix = "Null"
				} else {
					nullPrefix = "null"
				}

				nameUC := strings.ToUpper(string([]rune(name)[0])) + string([]rune(name)[1:])
				nameNan := nullPrefix + nameUC

				namePkg := "package " + *pkgName

				replacer := strings.NewReplacer(
					initialTypeName, name,
					generateTypeName, nameNan,
					valueFieldName, name,
					packageName, namePkg,
				)

				out += replacer.Replace(string(dataNan))

				// fmt.Println("struct", val.Fields.NumFields())
				// printer.Fprint(os.Stdout, fset, node)
				return true
			default:
				// printer.Fprint(os.Stdout, fset, node)
				// fset.Position(val.Pos()).
				// fmt.Println(val)
				// return true
				return false
			}
		})

		if len(out) == 0 {
			continue
		}

		out = fmt.Sprintf("// Code generated by \"nan %s\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " ")) + out

		ext := filepath.Ext(file)

		resName := file[0:len(file)-len(ext)] + "_nan" + ext

		if err := ioutil.WriteFile(resName, []byte(out), 0644); err != nil {
			panic(err)
		}
	}
}
